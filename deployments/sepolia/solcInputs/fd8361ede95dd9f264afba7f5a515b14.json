{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interface/IMultiSignWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IMultiSignWallet {\n\n    struct Transaction {\n        address to;\n        uint256 value;\n        bool executed;\n        uint numConfirmations;\n        address tokenaddress;\n    }\n\n    function submitTransaction(address _to, uint256 _value, address _tokenaddress) external;\n\n    function confirmTransaction(uint256 _txIndex) external;\n\n    function revokeConfirmation(uint256 _txIndex) external;\n\n    function executeTransaction(uint256 _txIndex) external;\n\n    event Deposit(address indexed sender, uint amount, uint balance);\n\n    event SubmitTransaction(\n        uint256 indexed txIndex,\n        address indexed owner,\n        address indexed to,\n        uint256 value,\n        address tokenaddress\n    );\n    \n    event ConfirmTransaction(address indexed owner, uint256 indexed txIndex);\n\n    event RevokeConfirmation(address indexed owner, uint256 indexed txIndex);\n\n    event ExecuteTransaction(address indexed owner, uint256 indexed txIndex);\n}"
    },
    "contracts/MultiSignWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interface/IMultiSignWallet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MultiSignWallet is IMultiSignWallet {\n    address[] public owners;\n    Transaction[] public transactions;\n    uint256 public minConfirmationsRequired;\n    mapping(address account => bool) isOwner;\n    mapping(uint256 index => mapping(address owner => bool)) isConfirmed;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not owner\");\n        _;\n    }\n\n    modifier txExists(uint _txIndex) {\n        require(_txIndex < transactions.length, \"tx does not exist\");\n        _;\n    }\n\n    modifier notExecuted(uint _txIndex) {\n        require(!transactions[_txIndex].executed, \"tx already executed\");\n        _;\n    }\n\n    modifier notConfirmed(uint _txIndex) {\n        require(!isConfirmed[_txIndex][msg.sender], \"tx already confirmed\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _minConfirmationsRequired) {\n        require(_owners.length > 0, \"owners required\");\n        require(\n            _minConfirmationsRequired > 0 &&\n                _minConfirmationsRequired <= _owners.length,\n            \"invalid number of required confirmations\"\n        );\n\n        for (uint i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n\n            require(owner != address(0), \"invalid owner\");\n            require(!isOwner[owner], \"owner not unique\");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        minConfirmationsRequired = _minConfirmationsRequired;\n    }\n\n    function submitTransaction(\n        address _to,\n        uint256 _value,\n        address _tokenaddress\n    ) external override onlyOwner {\n        uint256 txIndex = transactions.length;\n\n        transactions.push(\n            Transaction({\n                to: _to,\n                value: _value,\n                executed: false,\n                numConfirmations: 0,\n                tokenaddress:_tokenaddress\n            })\n        );\n\n        emit SubmitTransaction(txIndex, msg.sender, _to, _value,_tokenaddress);\n    }\n\n    function confirmTransaction(\n        uint256 _txIndex\n    ) external override onlyOwner txExists(_txIndex) notExecuted(_txIndex) notConfirmed(_txIndex) {\n        Transaction storage transaction = transactions[_txIndex];\n        ++transaction.numConfirmations;\n        isConfirmed[_txIndex][msg.sender] = true;\n\n        emit ConfirmTransaction(msg.sender, _txIndex);\n\n    }\n\n    function revokeConfirmation(\n        uint256 _txIndex\n    ) external override onlyOwner txExists(_txIndex) notExecuted(_txIndex) {\n        Transaction storage transaction = transactions[_txIndex];\n        require(isConfirmed[_txIndex][msg.sender], \"Tx not confirmed\");\n\n        --transaction.numConfirmations;\n        isConfirmed[_txIndex][msg.sender] = false;\n\n        emit RevokeConfirmation(msg.sender, _txIndex);\n    }\n\n    function executeTransaction(\n        uint256 _txIndex\n    ) external override onlyOwner txExists(_txIndex) notExecuted(_txIndex) {\n        Transaction storage transaction = transactions[_txIndex];\n        require(\n            transaction.numConfirmations >= minConfirmationsRequired,\n            \"cannot execute tx\"\n        );\n\n        transaction.executed = true;\n        if(transaction.tokenaddress == address(this))\n        {\n            require(address(this).balance>=transaction.value,\"lock of ETH\");\n            (bool success, ) = transaction.to.call{value: transaction.value}('');\n            require(success, \"Tx execute failed\");\n        }\n        else\n        {\n            IERC20 token = IERC20(transaction.tokenaddress);\n            require(token.balanceOf(address(this))>=transaction.value,\"lock of balance\");\n            bool ret = token.transfer(transaction.to,transaction.value);\n            require(ret, \"Tx execute failed\");\n        }\n\n\n        emit ExecuteTransaction(msg.sender, _txIndex);\n    }\n\n    function getOwners() external view returns (address[] memory) {\n        return owners;\n    }\n\n    function getTransactionCount() external view returns (uint) {\n        return transactions.length;\n    }\n\n    function getTransaction(\n        uint _txIndex\n    ) external view returns (Transaction memory) {\n        return transactions[_txIndex];\n    }\n\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}